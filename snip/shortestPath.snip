snippet     dijkstra
options     head 
    vector<i64> dijkstra(const WGraph &G, int src) // {{{
    {
        vector<i64> dist(G.size(), LINF);
        priority_queue<pii, vector<pii>, greater<pii>> pq;
    
        dist[src] = 0;
        pq.emplace(0, src);
    
        while(!pq.empty()) {
            const i64 nowCost = pq.top().first;
            const int nowNode = pq.top().second;
            pq.pop();
            if (dist[nowNode] < nowCost) continue;
    
            for (const auto &e : G[nowNode]) {
                const i64 newCost = nowCost + e.cost;
                if (chmin(dist[e.to], newCost)) {
                    pq.emplace(newCost, e.to);
                }
            }
        }
    
        return dist;
    }
    // }}}


snippet     bellmanFord
options     head 
    // 負閉路検出は別途 checkNegativeCycle() を用いてね
    vector<i64> bellmanFord(const Edges &es, int V, int src) // {{{
    {
        vector<i64> dist(V, LINF);
        dist[src] = 0;
    
        bool updated = true;
        for (int i = 0; updated && i < V-1; ++i) {
            updated = false;
            for (const auto &e : es) {
                if (dist[e.src] == LINF) continue;
                updated |= chmin(dist[e.to], dist[e.src] + e.cost);
            }
        }
    
        return dist;
    }
    // }}}


snippet     negativeCycle
alias       checkNegativeCycle 
options     head 
    vector<uint8_t> checkNegativeCycle(const Edges &es, int V, const vector<i64> &dist) // {{{
    {
        vector<uint8_t> negative(V, 0);
        for (int i = 0; i < V; ++i) {
            for (const auto &e : es) {
                if (dist[e.src] >= LINF) continue;
                negative[e.to] |= negative[e.src] |= (dist[e.to] > dist[e.src] + e.cost);
            }
        }
        return negative;
    }
    // }}}


snippet     SPFA
alias       spfa 
options     head 
    vector<i64> SPFA(const WGraph &G, int src) // {{{
    {
        vector<i64> dist(G.size(), LINF);
        vector<int> cnt(G.size(), 0);
        vector<bool> pending(G.size(), false);
        queue<int> que;
    
        que.emplace(src);
        ++cnt[src];
        dist[src] = 0;
    
        while(!que.empty()) {
            const int u = que.front(); que.pop();
            pending[u] = false;
            for (const auto &e : G[u]) {
                if (!chmin(dist[e.to], dist[u] + e.cost)) continue;
                if (pending[e.to]) continue;
                if (++cnt[e.to] >= G.size()) return {};
                pending[e.to] = true;
                que.emplace(e.to);
            }
        }
    
        return dist;
    }
    // }}}


snippet     floyd
alias       warshall warshallFloyd 
options     head 
    template<size_t N>
    int floyd(MatrixGraph<N> &G, int V) // {{{
    {
        for (int k = 0; k < V; ++k) {
            for (int i = 0; i < V; ++i) {
                if (G[i][k] >= LINF) continue;
                for (int j = 0; j < V; ++j) {
                    if (G[k][j] >= LINF) continue;
                    chmin(G[i][j], G[i][k] + G[k][j]);
                }
            }
        }
    
        for (int i = 0; i < V; ++i) if (G[i][i] < 0) return -1;
        return 0;
    }
    // }}}


